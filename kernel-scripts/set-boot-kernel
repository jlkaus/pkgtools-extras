#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use FindBin;

our $TOOLDIR = $FindBin::Bin;
our $BOOT_LOC = "/boot";
our $EFI_LOC = "${BOOT_LOC}/efi/EFI/Slackware";

my $analyze = undef;
my $lilo = undef;
my $elilo = undef;
my $set_new = undef;
my $set_old = undef;
my $clear_new = undef;
my $clear_old = undef;

if(!GetOptions('a|analyze' => \$analyze,
	       'l|lilo' => \$lilo,
	       'e|elilo' => \$elilo,
	       'n|set-new=s' => \$set_new,
	       'o|set-old=s' => \$set_old,
	       'clear-new' => \$clear_new,
	       'clear-old' => \$clear_old)) {
    print STDERR "Usage: set-boot-kernel [[-a|--analyze]] [-n VERSION|--set-new VERSION|--clear-new] [-o VERSION|--set-old VERSION|--clear-old] [[-e|--elilo]|-l|--lilo]\n";
    exit(64); # EX_USAGE
}

if(defined $set_new && defined $clear_new) {
    print STDERR "Only one of --set-new or --clear-new is allowed.\n";
    exit(64); # EX_USAGE
}

if(defined $set_old && defined $clear_old) {
    print STDERR "Only one of --set-old or --clear-old is allowed.\n";
    exit(64); # EX_USAGE
}

if(defined $lilo && defined $elilo) {
    print STDERR "Only one of --lilo or --elilo is allowed.\n";
    exit(64); # EX_USAGE
}

if(!defined $lilo) {
    $elilo = 1;
}

if(!defined $set_new && !defined $set_old && !defined $clear_new && !defined $clear_old) {
    $analyze = 1;
}

# default just displays current kernels running, installed, configured, etc.
# option to set the old kernel to a particular version (must be installed)
# option to set the new kernel to a particular version (must be installed)
# option to clear the old kernel
# option to clear the new kernel
# builds initrd when required.

# Does not download new kernels, or check for new kernels to download
# Does not installpkg any kernels
# Does not removepkg any kernels

# Assumes /etc/mkinitrd.conf is correct.
# Assumes elilo.conf is correct, and uses the vmlinuz, vmlinuz-huge, vmlinuz-old, vmlinuz-old-huge naming convention
# Assumes the efi slackware boot location is /boot/efi/EFI/Slackware/

# By default when setting a kernel to old or new, sets both the huge and generic
# ones.  If a huge or generic version isn't available, doesn't set that one (and
# removes the file altogether)
# Does not update elilo.conf if one or the other isn't available.

# If the desired kernel version isn't found, doesn't actually update anything,
# and errors out.

# If asking to clear the new kernel, warns on exit that you may be able to boot.

# Some sort of lilo option?  No EFI in that case.  Assumes lilo.conf is correct and references the correct names (as above).  Re-runs lilo after changes are made.


my @klines = $lilo ? `$TOOLDIR/check-kernels lilo` : `$TOOLDIR/check-kernels elilo`;
my %kdata = ();
foreach(@klines){
    chomp;
    my ($k,$v) = split /:\s*/;
#    print "$k=$v\n";
    my @vals = split /\s+/, $v;
    $kdata{$k} = [@vals];
}

my $rkd = {};
foreach(keys %kdata) {
    if(/^Running$/) {
	foreach(@{$kdata{$_}}) {
	    $rkd->{$_} = {} if !defined $rkd->{$_};
	    $rkd->{$_}->{Running} = 1;
	}
    } elsif(/^Installed-(.*)$/) {
	foreach(@{$kdata{$_}}) {
	    $rkd->{$_} = {} if !defined $rkd->{$_};
	    $rkd->{$_}->{$1} = 1;
	}
    } elsif(/^Configured-(.*)$/) {
	foreach(@{$kdata{$_}}) {
	    $rkd->{$_} = {} if !defined $rkd->{$_};
	    $rkd->{$_}->{$1} = 1;
	}
    }
}

if($analyze) {
    # Display current state, as retreived above.
    print("Current configuration:\n");

    # Also, determine if there are any installed kernels that are no longer used
    # And determine if we have generic kernels installed that don't have modules installed too.
    # Also, if neither a generic or huge kernel is configured as the "new" kernel, put out a warning.
    
}

if($set_new) {
    print("Setting new kernel to $set_new\n");
    # if generic && modules is installed:
    #   run mkinitrd
    #   link new generic to $boot/vmlinuz, etc.
    #   cp new generic to $efi/vmlinuz, etc.
    # if huge is installed:
    #   link new huge to $boot/vmlinuz-huge, etc.
    #   cp new huge to $efi/vmlinuz-huge, etc.
    # If neither is installed:
    #   error out
    
} elsif($clear_new) {
    print("Clearing new kernel\n");
    # If they exist:
    # Remove $boot/vmlinuz link, etc
    # Remove $efi/vmlinuz, etc
    # Remove $boot/vmlinuz-huge link, etc.
    # Remove $efi/vmlinuz-huge, etc.
    # Warn on exit
}

if($set_old) {
    print("Setting old kernel to $set_old\n");
    # if generic && modules is installed:
    #   run mkinitrd
    #   link old generic to $boot/vmlinuz-old, etc.
    #   cp old generic to $efi/vmlinuz-old, etc.
    # if huge is installed:
    #   link old huge to $boot/vmlinuz-old-huge, etc.
    #   cp old huge to $efi/vmlinuz-old-huge, etc.
    # if neither is installed:
    #   Error out

} elsif($clear_old) {
    print("Clearing old kernel\n");
    # If they exist:
    # Remove $boot/vmlinuz-old link, etc
    # Remove $efi/vmlinuz-old, etc
    # Remove $boot/vmlinuz-old-huge link, etc.
    # Remove $efi/vmlinuz-old-huge, etc.
}

exit(0);
