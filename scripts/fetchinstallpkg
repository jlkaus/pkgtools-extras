#!/bin/bash

TMPDIR=
function cleanup() {
    if [ -n "$TMPDIR" ]; then
	rm -rf $TMPDIR
    fi
}

function warn_msg() {
    echo "*** WARN: " "$@" >&2
}

function error_msg() {
    echo "*** ERROR: " "$@" >&2
}

function abort_clean() {
    exit_status=$1
    shift
    error_msg "$@"
    cleanup
    exit ${exit_status}
}

TMPDIR=$( mktemp -d --tmpdir fetchinstallpkg.XXXXXX )
if [ $? -ne 0 ]; then
    abort_clean 73 "Unable to create a temporary directory ($?)."
fi

trap 'cleanup' 2 14 15 EXIT


# Helper to combine fetchpkg and either installpkg or upgradepkg, depending on options.
# Options:
#  --no-verify         By default, allows fetchpkg to verify the package.  This disables that.  Use at own risk!
#  --reinstall         By default, a package that is already installed at the exact same version/build is skipped.  This forces it to be re-installed.  Ignored if --use-installpkg is used.
#  --use-installpkg        By default, upgradepkg is used. This forces installpkg to be used. Note this may result in incorrect behavior if the package is already installed.
#  --skip-new       By default, packages that are not locally installed at all are installed, as expected.  This instead causes packages that are not currently installed at all to be skipped.  Ignored if --use-installpkg is used.
#  --skip-missing      By default, if a specified package cannot be found on any remote repository, no packages will be installed/upgraded at all.  This forces the process to continue just skipping the missing package.  Note that download failures, or verification failures, will still cause the process to abort, without installing anything.

# The exact package name(s) needs to be specified.  No package searching is done.
# All packages are downloaded/verified before any installations occur.
# Uses a temporary download location, not the package cache or CWD.
# Download or verification failures abort the process before any installation occurs.
# An installation failure aborts the process at that point (no further installations are attempted. Previously successful installations are not undone.)
# No packages are left behind after the installations occur.

FETCHPKG_OPTS=
INSTALLER_CMD=upgradepkg
USE_REINSTALL=
USE_INSTALL_NEW=1
PKGNAMES=

while [ -n "$1" ]; do
    case $1 in
	--no-verify)
	    FETCHPKG_OPTS="${FETCHPKG_OPTS} --no-verify"
	    shift
	    ;;
	--skip-missing|-s)
	    FETCHPKG_OPTS="${FETCHPKG_OPTS} --skip-missing"
	    shift
	    ;;
	--reinstall|-r)
	    USE_REINSTALL=1
	    shift
	    ;;
	--use-installpkg|-i)
	    INSTALLER_CMD=installpkg
	    shift
	    ;;
	--skip-new)
	    USE_INSTALL_NEW=
	    shift
	    ;;
	*)
	    PKGNAMES="$PKGNAMES $1"
	    shift
	    ;;
    esac
done

if [ "$INSTALLER_CMD" = "upgradepkg" ]; then
    if [ -n "$USE_REINSTALL" ]; then
	INSTALLER_CMD="${INSTALLER_CMD} --reinstall"
    fi
    if [ -n "$USE_INSTALL_NEW" ]; then
	INSTALLER_CMD="${INSTALLER_CMD} --install-new"
    fi
fi

set -e

# First, pass the pkgnames to fetchpkg, with --skip-missing and --no-verify, if necessary
fetchpkg $FETCHPKG_OPTS -d $TMPDIR $PKGNAMES

# Next, install all downloaded packages:
${INSTALLER_CMD} $TMPDIR/*

cleanup
