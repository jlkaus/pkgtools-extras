#!/bin/bash

TMPDIR=
function cleanup() {
    if [ -n "$TMPDIR" ]; then
	rm -rf $TMPDIR
    fi
}

function warn_msg() {
    echo "*** WARN: " "$@" >&2
}

function error_msg() {
    echo "*** ERROR: " "$@" >&2
}

function abort_clean() {
    exit_status=$1
    shift
    error_msg "$@"
    cleanup
    exit ${exit_status}
}

# config file sourced from ${PKGTOOLS_EXTRAS_CONF:-/etc/pkgtools-extras.conf}.
PKGTOOLS_EXTRAS_CONF=${PKGTOOLS_EXTRAS_CONF:-/etc/pkgtools-extras.conf}
if [ ! -e ${PKGTOOLS_EXTRAS_CONF} ]; then
    abort_clean 78 "${PKGTOOLS_EXTRAS_CONF} does not exist.  Aborting."
fi

declare -A MIRRORS
. ${PKGTOOLS_EXTRAS_CONF}

# Allow WGETFLAGS to be empty, or the MIRRORS to be empty.
# If WORKDIR or PKGTOOLS_INSTALLED_PKGS_DIR are not set, terminate.
if [ -z "$WORKDIR" ]; then
    abort_clean 78 "WORKDIR needs to be set in the $PKGTOOLS_EXTRAS_CONF file.  Aborting."
fi
if [ -z "$PKGTOOLS_INSTALLED_PKGS_DIR" ] || ! [ -e $PKGTOOLS_INSTALLED_PKGS_DIR -a -d $PKGTOOLS_INSTALLED_PKGS_DIR ]; then
    abort_clean 78 "PKGTOOLS_INSTALLED_PKGS_DIR needs to be set in the $PKGTOOLS_EXTRAS_CONF file, and must exist and be a directory.  Aborting."
fi

if [ ! -e "${WORKDIR}/pkglist" -o ! -e "${WORKDIR}/PACKAGES.TXT" ]; then
    abort_clean 72 "No pkglist (or PACKAGES.TXT) found in ${WORKDIR}.  Please update the pkglist."
fi



# options:
#   --info: Show the slack-desc for each package (from PACKAGES.TXT or the installed package file)
#   --link: Show the direct download link for each package, if known.  Note that this is already included
#           for --info.
#   --status=STATUSLIST: Filter the results by install-status (or a comma-separated list of install-statuses):
#           installed (or inst or i)
#           available (or avail or a)
#           Default STATUSLIST is installed,available
#   --repo=REPOLIST: Filter the results based on which repo the package is from. By default, all repos
#           are accepted.  The special repo "__unknown__" is used when a package is only installed locally,
#           but is not available upstream (currently).  The special repo "__available__" can be used to select
#           packages available at some upstream repo (thus excluding packages installed locally but not
#           currently available upstream).  Default REPOLIST is __unknown__,__available__
#
# arguments:
#   PATTERN: swizzled before using as grep to the pkglist and the installed packages names

SHOW_INFO=
SHOW_LINK=
TERSE_MODE=
REPO_LIST="__unknown__ __available__"
MODE=flat
INCLUDE_UNAVAILABLE=
INCLUDE_UPTODATE=
INCLUDE_UPGRADES=
INCLUDE_NEW=
EXCLUSION_PATTERN=
BLACKLIST_FILE=
PATTERN=
while [ -n "$1" ]; do
    case $1 in
	--info|-i)
	    SHOW_INFO=1
	    shift
	    ;;
	--link|-l)
	    SHOW_LINK=1
	    shift
	    ;;
	--terse|-t)
	    TERSE_MODE=1
	    shift
	    ;;
	--actions)
	    shift
	    MODE=actions
	    ;;
	--include-unavailable)
	    shift
	    INCLUDE_UNAVAILABLE=1
	    ;;
	--include-uptodate)
	    shift
	    INCLUDE_UPTODATE=1
	    ;;
	--include-upgrades)
	    shift
	    INCLUDE_UPGRADES=1
	    ;;
	--include-new)
	    shift
	    INCLUDE_NEW=1
	    ;;
	--blacklist)
	    shift
	    BLACKLIST_FILE=$1
	    if [ ! -e ${BLACKLIST_FILE} -o ! -f ${BLACKLIST_FILE} -o ! -r ${BLACKLIST_FILE} ]; then
		abort_clean 66 "Specified blacklist file [${BLACKLIST_FILE}] doesn't exist or is not a readable file."
	    fi
	    shift
	    ;;
	--exclude)
	    shift
	    if [ -n "$EXCLUSION_PATTERN" ]; then
		EXCLUSION_PATTERN="${EXCLUSION_PATTERN} $1"
	    else
		EXCLUSION_PATTERN=$1
	    fi
	    shift
	    ;;
	--repo|-r|--repositories|--repos)
	    REPO_LIST=${2//,/ }
	    shift
	    shift
	    ;;
	*)
	    if [ -n "$PATTERN" ]; then
		PATTERN="$PATTERN $1"
	    else
		PATTERN=$1
	    fi
	    shift
	    ;;
    esac
done

REPO_LIST=${REPO_LIST//__available__/${!MIRRORS[@]}}
REPO_LIST=${REPO_LIST// /|}

if [ "$MODE" = "flat" -a -n "$INCLUDE_UPGRADES" ]; then
    INCLUDE_UPGRADES=
fi

if [ -z "$INCLUDE_NEW" -a -z "$INCLUDE_UPGRADES" -a -z "$INCLUDE_UPTODATE" -a -z "$INCLUDE_UNAVAILABLE" ]; then
    INCLUDE_NEW=1
    INCLUDE_UPGRADES=1
    INCLUDE_UPTODATE=1
    INCLUDE_UNAVAILABLE=1
fi

TRUE_PATTERN=$(echo $PATTERN |sed -e 's/\+/\\\+/g' -e 's/\./\\\./g' -e 's/ /\|/g')
TRUE_EXCLUDE=$(echo $EXCLUSION_PATTERN |sed -e 's/\+/\\\+/g' -e 's/\./\\\./g' -e 's/ /\|/g')

# Note: If PATTERN is an empty string, all packages will be returned, but if STATUS_LIST or REPO_LIST are empty,
# none of the PATTERN-matching packages will match the filter criteria, returning an empty list.

#echo "[$TRUE_PATTERN]"
#echo "[$TRUE_EXCLUDE]"
# By default, just displays, for each result:
# install-status source-repo packagename
# If --info specified, also dumps out the slackdesc info for that package, after the above.

DOEXCLUDE=
if [ -n "$TRUE_EXCLUDE" ]; then
    DOEXCLUDE="&& !/$TRUE_EXCLUDE/"
fi

MATCHING_PKGS=$(
    ( awk '{print $2}' ${WORKDIR}/pkglist;
      find ${PKGTOOLS_INSTALLED_PKGS_DIR}/ -type f -printf '%f\n' | sed -E -e 's/^(.*)-[^-]*-[^-]*-[^-]*$/\1/'
    ) | awk "/$TRUE_PATTERN/ ${DOEXCLUDE} { print }" |sort |uniq
	     )
if [ -n "$BLACKLIST_FILE" ]; then
    MATCHING_PKGS=$( echo "$MATCHING_PKGS" | grep -v -x -E -s -f $BLACKLIST_FILE )
fi

for x in ${MATCHING_PKGS}; do
    AVAIL_PKGS=$(awk "\$2==\"${x}\" { print \$1, \$2, \$6, \$7, \$8; } " ${WORKDIR}/pkglist)
    INST_PKGS=$(find ${PKGTOOLS_INSTALLED_PKGS_DIR}/ -type f -name "${x}-*" -printf '%f\n' |sed -E -e 's/^(.*)-[^-]*-[^-]*-[^-]*$/\1 &/' | awk '{print "__unknown__",$1,$2,"path","ext"}')

    if [ "$MODE" = "flat" ]; then
	declare -A DISPLAYED
	DISPLAYED=()
	while read -r repo short pkg path ext; do
	    if [ -n "$repo" -a "$short" = "${x}" ]; then
		if [ -z "${DISPLAYED[$pkg]}" ]; then
#		    echo "$repo $vers $pkg $path $ext"
		    DISPLAYED[$pkg]=1


		    PKG_DATA=( $(cat ${WORKDIR}/pkglist | awk "\$6==\"${pkg}\" { print \$1,\$7,\$6,\$8; exit }" ) )

		    AREPO=${PKG_DATA[0]}
		    ISTATE=avail
		    if [ -e "${PKGTOOLS_INSTALLED_PKGS_DIR}/${pkg}" ]; then
			ISTATE=inst
		    fi
		    if [ -z "$AREPO" ]; then
			AREPO=__unknown__
			REMOTE_PATH="__unknown__"
			DIRECT_LINK="__unknown__"
		    else
			MIRROR=${MIRRORS[$AREPO]}
			LOCAL_PATH=${PKG_DATA[1]}
			REMOTE_PATH=$(echo "$LOCAL_PATH/" |sed -e "s/^\\.\\/$AREPO\\///")
			PKGNAME="${PKG_DATA[2]}.${PKG_DATA[3]}"
			DIRECT_LINK=${MIRROR}${REMOTE_PATH}${PKGNAME}
		    fi

		    if [ -n "$INCLUDE_UNAVAILABLE" -a "$ISTATE" = "inst" -a "$AREPO" = "__unknown__" ] ||
			   [ -n "$INCLUDE_NEW" -a "$ISTATE" = "avail" ] ||
			   [ -n "$INCLUDE_UPTODATE" -a "$ISTATE" = "inst" -a "$AREPO" != "__unknown__" ]; then
			if echo "$AREPO" |grep -E -s -q -e "^${REPO_LIST}\$"; then
			    if [ -n "$SHOW_INFO" ]; then
				echo "PACKAGE_NAME: $pkg"
				echo "PACKAGE_LOCATION: $REMOTE_PATH"
				echo "REPOSITORY: $AREPO"
				echo "DIRECT_LINK: $DIRECT_LINK"
				if [ "$ISTATE" = "inst" ]; then
				    # For installed packages, the slack-desc should be in the package file
				    # in /var/lib/pkgtools/packages/PKGNAME:
				    # ...
				    # PACKAGE DESCRIPTION:
				    # {print}
				    # FILE LIST:
				    # {exit}
				    echo "STATUS: Installed"
				    echo "PACKAGE_DESCRIPTION:"
				    awk 'doprint && /^FILE LIST:$/ {exit} doprint {print} /^PACKAGE DESCRIPTION:$/ {doprint=1} ' ${PKGTOOLS_INSTALLED_PKGS_DIR}/${pkg}
				    echo
		    
				else
				    # For packages that are not installed, we'll have to look in PACKAGES.TXT
				    # {ignore}
				    # PACKAGE NAME: PKGNAME.ext
				    # {ignore}
				    # PACKAGE DESCRIPTION:
				    # {print}
				    # <BLANK>
				    # {exit}
				    echo "STATUS: Available"
				    echo "PACKAGE_DESCRIPTION:"
				    awk "doprint && /^\$/ {exit} doprint {print} isfound && /^PACKAGE DESCRIPTION:\$/ {doprint=1} /^PACKAGE NAME: +${pkg}\.t..\$/ {isfound=1}" ${WORKDIR}/PACKAGES.TXT
				    echo
				fi
			    else
				if [ -n "$TERSE_MODE" ]; then
				    if [ -z "$SHOW_LINK" ]; then
					echo $pkg
				    else
					if [ "$DIRECT_LINK" != "__unknown__" ]; then
					    echo $DIRECT_LINK
					fi
				    fi
				else
				    if [ -n "$SHOW_LINK" ]; then
					printf "%-6s %-40s %-26s %s\n" $ISTATE $pkg $AREPO $DIRECT_LINK
				    else
					printf "%-6s %-40s %-26s\n" $ISTATE $pkg $AREPO
				    fi
				fi
			    fi
			fi
		    fi
		fi
	    fi
	done <<< "$INST_PKGS"$'\n'"$AVAIL_PKGS"
    else
	INSTALLED=
	while read -r repo short pkg path ext; do
	    if [ -n "$repo" -a "$short" = "${x}" ]; then
		INSTALLED=1

		EXACT_REPO=
#		EXACT_LINK=
		UPGRADES=
		while read -r arepo ashort apkg apath aext; do
		    if [ -n "$arepo" -a "$ashort" = "${x}" ] && echo "$arepo" |grep -E -s -q -e "^${REPO_LIST}\$"; then

			MIRROR=${MIRRORS[$arepo]}
			LOCAL_PATH=$apath
			REMOTE_PATH=$(echo "$LOCAL_PATH/" |sed -e "s/^\\.\\/$arepo\\///")
			PKGNAME="${apkg}.${aext}"
			DIRECT_LINK=${MIRROR}${REMOTE_PATH}${PKGNAME}

			if [ "$pkg" = "$apkg" ]; then
			    EXACT_REPO=$arepo
#			    EXACT_LINK=${DIRECT_LINK}
			else
			    UPGRADES="$UPGRADES $arepo:$apkg"
#			    if [ -n "$SHOW_LINK" ]; then
#				UPGRADES="$UPGRADES:$DIRECT_LINK"
#			    fi
			fi
		    fi
		done <<< "$AVAIL_PKGS"

		action=
		from=$EXACT_REPO
#		if [ -n "$SHOW_LINK" ]; then
#		    from="${from}:$EXACT_LINK"
#		fi
		if [ -n "$UPGRADES" ]; then
		    action=upgrade
		elif [ -n "$EXACT_REPO" ]; then
		    action=uptodate
		else
		    action=unavailable
		fi
		
		if [ "$action" = "upgrade" -a -n "$INCLUDE_UPGRADES" ] ||
		       [ "$action" = "uptodate" -a -n "$INCLUDE_UPTODATE" ] ||
		       [ "$action" = "unavailable" -a -n "$INCLUDE_UNAVAILABLE" ]; then
		    printf "%-12s %-40s %s" "$action" "$pkg" "[$from]"
		    if [ -n "$UPGRADES" ]; then
			for y in $UPGRADES; do
			    echo -n " $y"
			done
		    fi
		    echo
		fi
	    fi
	done <<< "$INST_PKGS"

	if [ -z "$INSTALLED" -a -n "$INCLUDE_NEW" ]; then
	    while read -r arepo ashort apkg apath aext; do
		if [ -n "$arepo" -a "$ashort" = "${x}" ] && echo "$arepo" |grep -E -s -q -e "^${REPO_LIST}\$"; then
		    MIRROR=${MIRRORS[$arepo]}
		    LOCAL_PATH=$apath
		    REMOTE_PATH=$(echo "$LOCAL_PATH/" |sed -e "s/^\\.\\/$arepo\\///")
		    PKGNAME="${apkg}.${aext}"
		    DIRECT_LINK=${MIRROR}${REMOTE_PATH}${PKGNAME}

		    action=new
		    from=$arepo
#		    if [ -n "$SHOW_LINK" ]; then
#			from="${from}:$DIRECT_LINK"
#		    fi

		    printf "%-12s %-40s %s\n" "$action" "$apkg" "[$from]"
		fi
	    done <<< "$AVAIL_PKGS"
	fi
    fi

done

cleanup
