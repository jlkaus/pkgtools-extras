#!/bin/bash

PKG_LIST_LOC=/var/lib/pkgtools/packages

TMPDIR=
function cleanup() {
    if [ -n "$TMPDIR" ]; then
	rm -rf $TMPDIR
    fi
}

function warn_msg() {
    echo "*** WARN: " "$@" >&2
}

function error_msg() {
    echo "*** ERROR: " "$@" >&2
}

function abort_clean() {
    exit_status=$1
    shift
    error_msg "$@"
    cleanup
    exit ${exit_status}
}

trap 'cleanup' 2 14 15
set -e

# The tool now uses check-kernels --boot-config to get details about lilo/elilo config data.
# For a given allowed tag that is configured, that will give information about where to copy/link the
# desired kernel and initrd files.
# Use the actual package database to determine the installed kernel versions
# Still will need to create initrd if necessary.
# Allow any configured valid tags, not restricted to old/new/etc.

# options now:
# --list    Just list the current boot configs _that we can manipulate_! Show tags, labels, initrd status, default status, and current kernel package used.
# --skip-initrd   Even if currently using an initrd, don't rebuild or replace the initrd image.  Use at your own risk!
# --no-lilo       If a given tag we're changing is in lilo.conf, lilo is re-run after changes, normally, but this causes it not to be run.
# --set TAG=SIZE-VERSION    For the config of TAG (if configured, or complain), copy in the SIZE-VERSION kernel (if installed, or complain) to the appropriate place, and initrd too, created if needed.
# --clear TAG               For the config of TAG (if configured, or complain), remove the current kernel.  This will cause that TAG to no longer validly boot.
# Can specify several --set and/or --clear options in a single invocation.

SHOW_LIST=
NO_LILO=
CHANGES=
DRY_RUN=
SKIP_INITRD=

while [ -n "$1" ]; do
    case $1 in
	--list|-l)
	    SHOW_LIST=1
	    shift
	    ;;
	--no-lilo)
	    NO_LILO=1
	    shift
	    ;;
	--skip-initrd)
	    SKIP_INITRD=1
	    shift
	    ;;
	--clear|-c)
	    shift
	    CHANGES="$CHANGES $1="
	    shift
	    ;;
	--set|-s)
	    shift
	    CHANGES="$CHANGES $1"
	    shift
	    ;;
	--dry-run|-d)
	    DRY_RUN=1
	    shift
	    ;;
	*)
	    abort_clean 64 "Unknown parameter $1"
	    ;;
    esac
done

if [ -z "$CHANGES" ]; then
    SHOW_LIST=1
fi

# Read in the current lilo/elilo configuration
BOOT_CONFIGS=$(check-kernels --boot-configs)

# Translate the configs into a map keyed by just valid tags.
# If desired, show the current valid configs
if [ -n "$SHOW_LIST" ]; then
    echo "Current boot configuration:"
fi
declare -A BC_IMAGE
declare -A BC_INITRD
declare -A BC_TOOL
while read -r tag vers image package initrd initrd_status tool dflt label ; do
    if [ "$tag" != "__invalid_tag__" ]; then
	if [ -n "$SHOW_LIST" ]; then
	    # Show tags, labels, initrd status, default status, and current kernel package used.
	    if [ "$dflt" = "__default__" ]; then
		simple_default=",default"
	    fi
	    simple_initrd_status=${initrd_status//__/}
	    simple_initrd_status=${simple_initrd_status//_/-}
	    echo "  $tag=$package \"$label\" ($simple_initrd_status$simple_default)"
	    echo "    image=$image"
	    if [ "$initrd" != "__none__" ]; then
		echo "    initrd=$initrd"
	    fi
	fi
	if [ -n "${BC_IMAGE[$tag]}" ]; then
	    abort_clean 78 "Duplicate boot configuration tag [$tag]"
	fi
	BC_IMAGE[$tag]=$image
	BC_INITRD[$tag]=$initrd
	BC_TOOL[$tag]=$tool
    fi
done <<< "$BOOT_CONFIGS";


RERUN_LILO=
CHANGES_VALIDATED=1

# If anything is set in the changes list, validate that the tags each exist and are modifyable, and verify the target is either empty, or refers to a valid installed kernel package.
# If everything validated OK about the changes list, go through each entry and apply the changes in turn.  For each kernel, determine if initrd needs to be built for it, and if lilo needs to be run after everything is done.
if [ -n "$CHANGES" ]; then
    echo
    echo "Validating requested changes ..."
    echo

    for x in $CHANGES; do
	VALS=( ${x//=/ } )
	tag=${VALS[0]}
	target=${VALS[1]}
	if [ -z "${BC_TOOL[$tag]}" ]; then
	    warn_msg "Tag [$tag] not found as valid tag in lilo.conf or elilo.conf"
	    CHANGES_VALIDATED=
	else
	    if [ "${BC_TOOL[$tag]}" = "__lilo__" ]; then
		RERUN_LILO=1
	    fi
	    if [ -n "$target" ]; then
		size=${target##kernel-}
		size=${size%%-*}
		vers=${target##kernel-${size}-}
		vers=${vers%%-*}
		excess=${target##kernel-${size}-${vers}-}
		if [ ! -e $PKG_LIST_LOC/kernel-${size}-${vers}-${excess} ]; then
		    warn_msg "Target for tag $tag: [$target] (${size}-${vers}) is not a currently installed kernel package."
		    CHANGES_VALIDATED=
		elif [ "${size}" = "generic" -a "${BC_INITRD[$tag]}" = "__none__" ]; then
		    warn_msg "Target for tag $tag is a generic kernel, but no initrd image path is specified in the configuration."
		    CHANGES_VALIDATED=
		elif [ ! -e /boot/vmlinuz-${size}-${vers} ]; then
		    warn_msg "Target for tag $tag is missing the kernel image file at [/boot/vmlinuz-${size}-${vers}]."
		    CHANGES_VALIDATED=
		else		
		    :
		fi
	    else
		:
	    fi
	fi
    done

    if [ -n "$CHANGES_VALIDATED" ]; then
	for x in $CHANGES; do
	    echo "Executing change [$x]:"
	    VALS=( ${x//=/ } )
	    tag=${VALS[0]}
	    target=${VALS[1]}
	    if [ -z "$target" ]; then
		echo "  Removing kernel image ${BC_IMAGE[$tag]} ..."
		if [ -z "$DRY_RUN" ]; then
		    rm -f ${BC_IMAGE[$tag]}
		else
		    echo "    # rm -f ${BC_IMAGE[$tag]}"
		fi
		if [ "${BC_INITRD[$tag]}" != "__none__" ]; then
		    if [ -z "$SKIP_INITRD" ]; then
			echo "  Removing initrd image ${BC_INITRD[$tag]} ..."
			if [ -z "$DRY_RUN" ]; then
			    rm -f ${BC_INITRD[$tag]}
			else
			    echo "    # rm -f ${BC_INITRD[$tag]}"
			fi
		    else
			echo "  Skipping removal of initrd image ${BC_INITRD[$tag]}."
		    fi
		fi
		warn_msg "Kernel tagged [$tag] was removed!  If this is a default boot config, please set it to something before rebooting!"
	    else
		size=${target##kernel-}
		size=${size%%-*}
		vers=${target##kernel-${size}-}
		vers=${vers%%-*}
		excess=${target##kernel-${size}-${vers}-}

		tgt_image=/boot/vmlinuz-${size}-${vers}
		tgt_initrd=/boot/initrd-${size}-${vers}.gz

		if [ "${BC_INITRD[$tag]}" != "__none__" ]; then
		    if [ -z "$SKIP_INITRD" ]; then
			echo "  Building new initrd [$tgt_initrd] for kernel ${vers} ..."
			if [ -z "$DRY_RUN" ];then
			    mkinitrd -F -c -k ${vers} -o ${tgt_initrd}
			else
			    echo "    # mkinitrd -F -c -k ${vers} -o ${tgt_initrd}"
			fi
		    else
			warn_msg "Skipping creation of new initrd [$tgt_initrd] for kernel ${vers}!  You almost certainly will need to do this manually!"
		    fi
		fi

		echo "  Copying kernel image [$tgt_image] into place at [${BC_IMAGE[$tag]}] ..."
		if [ -z "$DRY_RUN" ]; then
		    cp -a $tgt_image ${BC_IMAGE[$tag]}
		else
		    echo "    # cp -a $tgt_image ${BC_IMAGE[$tag]}"
		fi

		if [ "${BC_INITRD[$tag]}" != "__none__" ]; then
		    if [ -z "$SKIP_INITRD" ]; then
			echo "  Copying initrd image [$tgt_initrd] into place at [${BC_INITRD[$tag]}] ..."
			if [ -z "$DRY_RUN" ]; then
			    cp -a $tgt_initrd ${BC_INITRD[$tag]}
			else
			    echo "    # cp -a $tgt_initrd ${BC_INITRD[$tag]}"
			fi
		    else
			warn_msg "Skipping copying of new initrd [$tgt_initrd] into place at [${BC_INITRD[$tag]}]!  You almost certainly will need to do this manually!"
		    fi
		fi
	    fi
	    echo
	done

	if [ -n "$RERUN_LILO" ]; then
	    if [ -z "$NO_LILO" ]; then
		echo "Running lilo ..."
		if [ -z "$DRY_RUN" ]; then
		    lilo
		else
		    echo "  # lilo"
		fi
	    else
		warn_msg "--no-lilo was specified, but a kernel controlled by lilo.conf was modified.  Please re-run 'lilo' before rebooting!"
	    fi
	fi

	if [ -n "$DRY_RUN" ]; then
	    echo "Dry-run complete."
	    echo
	else
	    echo "Changes complete."
	    echo
	fi

    else
	abort_clean 1 "Invalid changes specified.  Aborting."
    fi
fi

cleanup
