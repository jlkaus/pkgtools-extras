#!/bin/bash

function cleanup() {
    if [ -n "$TMPDIR" ]; then
	rm -rf $TMPDIR
    fi
}

function warn_msg() {
    echo "*** WARN: " "$@" >&2
}

function error_msg() {
    echo "*** ERROR: " "$@" >&2
}

function abort_clean() {
    exit_status=$1
    shift
    error_msg "$@"
    cleanup
    exit ${exit_status}
}

# config file sourced from ${PKGTOOLS_EXTRAS_CONF:-/etc/pkgtools-extras.conf}.
PKGTOOLS_EXTRAS_CONF=${PKGTOOLS_EXTRAS_CONF:-/etc/pkgtools-extras.conf}
if [ ! -e ${PKGTOOLS_EXTRAS_CONF} ]; then
    abort_clean 78 "${PKGTOOLS_EXTRAS_CONF} does not exist.  Aborting."
fi

declare -A MIRRORS
. ${PKGTOOLS_EXTRAS_CONF}

# Allow WGETFLAGS to be empty, or the MIRRORS to be empty.
# If WORKDIR or PKGTOOLS_INSTALLED_PKGS_DIR are not set, terminate.
if [ -z "$WORKDIR" ]; then
    abort_clean 78 "WORKDIR needs to be set in the $PKGTOOLS_EXTRAS_CONF file.  Aborting."
fi
if [ -z "$PKGTOOLS_INSTALLED_PKGS_DIR" ] || ! [ -e $PKGTOOLS_INSTALLED_PKGS_DIR -a -d $PKGTOOLS_INSTALLED_PKGS_DIR ]; then
    abort_clean 78 "PKGTOOLS_INSTALLED_PKGS_DIR needs to be set in the $PKGTOOLS_EXTRAS_CONF file, and must exist and be a directory.  Aborting."
fi

if [ ! -e "${WORKDIR}/pkglist" -o ! -e "${WORKDIR}/PACKAGES.TXT" ]; then
    abort_clean 72 "No pkglist (or PACKAGES.TXT) found in ${WORKDIR}.  Please update the pkglist."
fi



# options:
#   --info: Show the slack-desc for each package (from PACKAGES.TXT or the installed package file)
#   --link: Show the direct download link for each package, if known.  Note that this is already included
#           for --info.
#   --status=STATUSLIST: Filter the results by install-status (or a comma-separated list of install-statuses):
#           installed (or inst or i)
#           available (or avail or a)
#           Default STATUSLIST is installed,available
#   --repo=REPOLIST: Filter the results based on which repo the package is from. By default, all repos
#           are accepted.  The special repo "__unknown__" is used when a package is only installed locally,
#           but is not available upstream (currently).  The special repo "__available__" can be used to select
#           packages available at some upstream repo (thus excluding packages installed locally but not
#           currently available upstream).  Default REPOLIST is __unknown__,__available__
#
# arguments:
#   PATTERN: swizzled before using as grep to the pkglist and the installed packages names

SHOW_INFO=
SHOW_LINK=
STATUS_LIST="installed available"
REPO_LIST="__unknown__ __available__"
PATTERN=
while [ -n "$1" ]; do
    case $1 in
	--info)
	    SHOW_INFO=1
	    shift
	    ;;
	--link)
	    SHOW_LINK=1
	    shift
	    ;;
	--status)
	    STATUS_LIST=${2//,/ }
	    shift
	    shift
	    ;;
	--repo)
	    REPO_LIST=${2//,/ }
	    shift
	    shift
	    ;;
	*)
	    if [ -n "$PATTERN" ]; then
		PATTERN="$PATTERN $1"
	    else
		PATTERN=$1
	    fi
	    shift
	    ;;
    esac
done

REPO_LIST=${REPO_LIST//__available__/${!MIRRORS[@]}}
REPO_LIST=${REPO_LIST// /|}

TRUE_PATTERN=$(echo $PATTERN |sed -e 's/\+/\\\+/g' -e 's/\./\\\./g' -e 's/ /\|/g')

INCLUDE_INSTALLED=
INCLUDE_AVAILABLE=
for x in $STATUS_LIST; do
    case $x in
	i|I|inst|installed|Installed)
	    INCLUDE_INSTALLED=1
	    ;;
	a|A|avail|available|Available)
	    INCLUDE_AVAILABLE=1
	    ;;
	*)
	    warn_msg "Ignoring unknown STATUS selector: $x"
	    ;;
    esac
done

#echo "WORKDIR=$WORKDIR"
#echo "MIRRORS="
#for x in "${!MIRRORS[@]}"; do
#    echo "    $x ${MIRRORS[$x]}"
#done
#echo "SHOW_INFO=$SHOW_INFO"
#echo "INCLUDE_INSTALLED=$INCLUDE_INSTALLED"
#echo "INCLUDE_AVAILABLE=$INCLUDE_AVAILABLE"
#echo "REPO_LIST=$REPO_LIST"
#echo "PATTERN=$PATTERN"
#echo "TRUE_PATTERN=$TRUE_PATTERN"
#echo

# Note: If PATTERN is an empty string, all packages will be returned, but if STATUS_LIST or REPO_LIST are empty,
# none of the PATTERN-matching packages will match the filter criteria, returning an empty list.

# By default, just displays, for each result:
# install-status source-repo packagename
# If --info specified, also dumps out the slackdesc info for that package, after the above.

MATCHING_PKGS=$(
    ( cat ${WORKDIR}/pkglist;
      find ${PKGTOOLS_INSTALLED_PKGS_DIR}/ -printf '%P\n' | sed -E -e 's/^(.*)-[^-]*-[^-]*-[^-]*$/\1 &/' | awk '{print "__unknown__",$1,"ver","arch","build",$2,"path","ext"}'
    ) | awk "\$2~/$PATTERN/ { print \$6 }" |sort |uniq
	     )

for x in ${MATCHING_PKGS}; do
    PKG_DATA=( $(cat ${WORKDIR}/pkglist | awk "\$6==\"${x}\" { print \$1,\$7,\$6,\$8; exit }" ) )
    AREPO=${PKG_DATA[0]}
    ISTATE=avail
    if [ -e "${PKGTOOLS_INSTALLED_PKGS_DIR}/${x}" ]; then
	ISTATE=inst
    fi
    if [ -z "$AREPO" ]; then
	AREPO=__unknown__
	REMOTE_PATH="__unknown__"
	DIRECT_LINK="__unknown__"
    else
	MIRROR=${MIRRORS[$AREPO]}
	LOCAL_PATH=${PKG_DATA[1]}
	REMOTE_PATH=$(echo "$LOCAL_PATH/" |sed -e "s/^\\.\\/$AREPO\\///")
	PKGNAME="${PKG_DATA[2]}.${PKG_DATA[3]}"
	DIRECT_LINK=${MIRROR}${REMOTE_PATH}${PKGNAME}
    fi

    if [ -n "$INCLUDE_INSTALLED" -a "$ISTATE" = "inst" ] || [ -n "$INCLUDE_AVAILABLE" -a "$ISTATE" = "avail" ]; then
	if echo "$AREPO" |grep -E -s -q -e "^${REPO_LIST}\$"; then
	    if [ -n "$SHOW_INFO" ]; then
		echo "PACKAGE_NAME: $x"
		echo "PACKAGE_LOCATION: $REMOTE_PATH"
		echo "REPOSITORY: $AREPO"
		echo "DIRECT_LINK: $DIRECT_LINK"
		if [ "$ISTATE" = "inst" ]; then
		    # For installed packages, the slack-desc should be in the package file
		    # in /var/lib/pkgtools/packages/PKGNAME:
		    # ...
		    # PACKAGE DESCRIPTION:
		    # {print}
		    # FILE LIST:
		    # {exit}
		    echo "STATUS: Installed"
		    echo "PACKAGE_DESCRIPTION:"
		    awk 'doprint && /^FILE LIST:$/ {exit} doprint {print} /^PACKAGE DESCRIPTION:$/ {doprint=1} ' ${PKGTOOLS_INSTALLED_PKGS_DIR}/${x}
		    echo
		    
		else
		    # For packages that are not installed, we'll have to look in PACKAGES.TXT
		    # {ignore}
		    # PACKAGE NAME: PKGNAME.ext
		    # {ignore}
		    # PACKAGE DESCRIPTION:
		    # {print}
		    # <BLANK>
		    # {exit}
		    echo "STATUS: Available"
		    echo "PACKAGE_DESCRIPTION:"
		    awk "doprint && /^\$/ {exit} doprint {print} isfound && /^PACKAGE DESCRIPTION:\$/ {doprint=1} /^PACKAGE NAME: +${x}\.t..\$/ {isfound=1}" ${WORKDIR}/PACKAGES.TXT
		    echo
		fi
	    else
		if [ -n "$SHOW_LINK" ]; then
		    printf "%-6s %-26s %-22s %-40s %s\n" $ISTATE $AREPO $REMOTE_PATH $x $DIRECT_LINK
		else
		    printf "%-6s %-26s %-22s %s\n" $ISTATE $AREPO $REMOTE_PATH $x
		fi
	    fi
	fi
    fi
done

cleanup
